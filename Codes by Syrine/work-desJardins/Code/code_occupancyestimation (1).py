# -*- coding: utf-8 -*-
# """code-occupancyestimation.ipynb

# Automatically generated by Colab.

# Original file is located at
#     https://colab.research.google.com/drive/1TYiry9DEsn-aJNMb_x5-uEicaZE_wLxI
# """

import cv2
import numpy as np
from google.colab import files
from google.colab.patches import cv2_imshow

# Upload the image file
uploaded = files.upload()

# Get the uploaded file name
filename = list(uploaded.keys())[0]

# Read the uploaded image using OpenCV
image = cv2.imread(filename)

# Convert the image to grayscale
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Apply adaptive thresholding for better separation
binary_image = cv2.adaptiveThreshold(gray_image, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                     cv2.THRESH_BINARY, 11, 2)

# Apply morphological operations to clean the image
kernel = np.ones((3, 3), np.uint8)
binary_image = cv2.morphologyEx(binary_image, cv2.MORPH_OPEN, kernel)

# Display the binary image using cv2_imshow
cv2_imshow(binary_image)

print("Blob Calculation \n")

# Parameters for blob detection
K = 100  # Sensitivity
L = 50  # Minimum blob size to count as a person

# Blob detector function (iterative using stack)
def blob_detector_iterative(i, j, visited, color):
    stack = [(i, j)]
    blob_size = 0
    blob_pixels = []
    visited[i, j] = color

    while stack:
        ci, cj = stack.pop()
        blob_size += 1
        blob_pixels.append((ci, cj))

        # Check neighbors in all 8 directions
        for ni, nj in [(ci-1, cj-1), (ci-1, cj), (ci-1, cj+1),
                       (ci, cj-1),           (ci, cj+1),
                       (ci+1, cj-1), (ci+1, cj), (ci+1, cj+1)]:
            if 0 <= ni < binary_image.shape[0] and 0 <= nj < binary_image.shape[1]:
                if binary_image[ni, nj] == 0 and visited[ni, nj] == 0:
                    visited[ni, nj] = color
                    stack.append((ni, nj))

    return blob_size, blob_pixels

# Initialize visited array and other variables
visited = np.zeros_like(binary_image)
blobs = []
color = 1

# Perform blob detection
for i in range(binary_image.shape[0]):
    for j in range(binary_image.shape[1]):
        if binary_image[i, j] == 0 and visited[i, j] == 0:  # Only process foreground pixels
            size, blob_pixels = blob_detector_iterative(i, j, visited, color)
            if size >= L:  # Filter by blob size (if size is large enough)
                color += 1

                # Convert list of blob pixels to a NumPy array for boundingRect
                blob_pixels_np = np.array(blob_pixels)

                # Use cv2.boundingRect to get the bounding box of the blob
                x, y, w, h = cv2.boundingRect(blob_pixels_np)
                cv2.rectangle(image, (x, y), (x + w, y + h), (0, 255, 0), 2)  # Draw green bounding box

# Display the image with bounding boxes
cv2_imshow(image)

# Occupancy Estimation
num_people = color - 1  # Number of detected blobs
print(f"Estimated number of people in the room: {num_people}")

